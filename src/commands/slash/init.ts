import { ICommand, CommandContext, CommandResult } from '../ICommand';
import * as vscode from 'vscode';

/**
 * InitCommand: åˆå§‹åŒ– Opengravity æ ‡å‡†å·¥ä½œæµ
 * åˆ›å»ºæ ¸å¿ƒ 6 æ–‡ä»¶å¤¹æ¶æ„å¹¶ç”Ÿæˆé¡¹ç›®è§„èŒƒ
 */
export class InitCommand implements ICommand {
    name = 'init';
    description = 'åˆå§‹åŒ– Opengravity æ ‡å‡†å·¥ä½œæµç›®å½•ç»“æ„';

    private readonly CORE_FOLDERS = [
        'codes',
        'brainstorm',
        'daily',
        'notes',
        'reviews',
        'todo'
    ];

    private readonly SKILL_FOLDERS = [
        'skills',
        'agents',
        'codingstyle',
        'commands'
    ];

    async execute(args: string[], context: CommandContext): Promise<CommandResult> {
        const rootPath = vscode.workspace.workspaceFolders?.[0]?.uri;
        if (!rootPath) {
            return { status: 'error', message: 'âŒ å½“å‰æœªæ‰“å¼€ä»»ä½•å·¥ä½œåŒºï¼Œæ— æ³•åˆå§‹åŒ–ã€‚' };
        }

        // 1. ç”¨æˆ·ç¡®è®¤
        const confirm = await vscode.window.showWarningMessage(
            '[ğŸš€] ç¡®è®¤åœ¨è¯¥å·¥ä½œåŒºåˆå§‹åŒ– Opengravity å·¥ä½œæµ?\nè¿™å°†åˆ›å»ºæ ¸å¿ƒæ–‡ä»¶å¤¹åŠ .opengravity é…ç½®åº“ã€‚',
            { modal: true },
            'ç«‹å³åˆå§‹åŒ–'
        );

        if (confirm !== 'ç«‹å³åˆå§‹åŒ–') {
            return { status: 'intercepted', message: 'ç”¨æˆ·å·²å–æ¶ˆã€‚' };
        }

        try {
            // 2. åˆ›å»ºæ ¸å¿ƒ 6 æ–‡ä»¶å¤¹
            for (const folder of this.CORE_FOLDERS) {
                const folderUri = vscode.Uri.joinPath(rootPath, folder);
                await vscode.workspace.fs.createDirectory(folderUri);
            }

            // 3. åˆ›å»º .opengravity å†…éƒ¨æŠ€èƒ½åº“
            const configDir = vscode.Uri.joinPath(rootPath, '.opengravity');
            for (const folder of this.SKILL_FOLDERS) {
                const folderUri = vscode.Uri.joinPath(configDir, folder);
                await vscode.workspace.fs.createDirectory(folderUri);
            }

            // 4. ç”Ÿæˆ .opengravity/GEMINI.md æ¨¡æ¿
            await this.generateGeminiDoc(rootPath);

            const successMsg = [
                "### ğŸ‰ å·¥ä½œæµç©ºé—´åˆå§‹åŒ–æˆåŠŸï¼",
                "",
                "**1. æ ¸å¿ƒå·¥ä½œæµï¼š**",
                "- `codes/`, `brainstorm/`, `daily/`, `notes/`, `reviews/`, `todo/`",
                "",
                "**2. æŠ€èƒ½ç³»ç»Ÿ (.opengravity/)ï¼š**",
                "- `skills/`: å­˜æ”¾å…·ä½“çš„ Skill Markdown æ¨¡æ¿",
                "- `agents/`: å­˜æ”¾ AI è§’è‰²å®šä¹‰",
                "- `codingstyle/`: å­˜æ”¾å›¢é˜Ÿä»£ç è§„èŒƒ",
                "- `commands/`: å­˜æ”¾è‡ªå®šä¹‰ .toml æŒ‡ä»¤",
                "",
                "æ‚¨å¯ä»¥å¼€å§‹åœ¨ `commands/` ä¸‹ç¼–å†™æŒ‡ä»¤å¹¶å¼•ç”¨å…¶ä»–ç›®å½•ä¸­çš„æ¨¡æ¿äº†ã€‚"
            ].join('\n');

            await context.webview.postMessage({
                type: 'aiResponse',
                value: successMsg
            });

            return { status: 'success' };

        } catch (error: any) {
            return { status: 'error', message: `âŒ åˆå§‹åŒ–å¤±è´¥: ${error.message}` };
        }
    }

    private async generateGeminiDoc(rootUri: vscode.Uri) {
        const geminiDir = vscode.Uri.joinPath(rootUri, '.opengravity');
        const geminiDoc = vscode.Uri.joinPath(geminiDir, 'GEMINI.md');

        const template = [
            "# Project Context (GEMINI.md)",
            "",
            "## ğŸ§  å¼€å‘çº¦å®š (Memories)",
            "- ç¦æ­¢ä»»ä½•å‡è®¾ï¼Œé¢å¯¹æœªçŸ¥æ—¶è¯¢é—®ç”¨æˆ·ã€‚",
            "- æ•ˆç‡ä½ä¸‹å’Œé‡åˆ°æŒ«æŠ˜å¾€å¾€æ¥æºäºå‡è®¾ï¼Œä¿¡æ¯ä¸è¶³ã€‚",
            "",
            "---",
            "*This file is auto-generated by Opengravity.*"
        ].join('\n');

        const encoder = new TextEncoder();
        await vscode.workspace.fs.writeFile(geminiDoc, encoder.encode(template));
    }
}
